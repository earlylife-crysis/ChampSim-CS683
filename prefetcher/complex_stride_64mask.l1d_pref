#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define NUM_IP_TABLE_ENTRIES 1024           // IP table entries
#define PREFETCH_DEGREE 5                   // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

// ------------ YOU CAN CHANGE THE IP_TABLE FOR YOU DESIGN ---------------- //
class IP_TABLE {
    public:
    uint8_t valid;        // Validity bit
    uint64_t ip;          // IP
    uint64_t signature;   // Signature corresponding to IP
    uint64_t target_addr; // Address targetted by IP (used to compute stride)

    // Defining the constructor
    IP_TABLE()
    {
        valid = 0;
        ip = 0;
        signature = 0;
        target_addr = 0;
    }
};

class CSPT {
    public:
    uint8_t valid;
    uint64_t signature;
    int stride;
    uint8_t confidence;

    // Defining the constructor
    CSPT()
    {
        valid = 0;
        signature = 0;
        stride = 0;
        confidence = 0;
    }
};

IP_TABLE trackers_ip[NUM_IP_TABLE_ENTRIES];

// Add CSPT entries
CSPT trackers_cspt[NUM_IP_TABLE_ENTRIES];

// ------------------------- Updating the signature ---------------------------- // 
uint64_t update_sig_l1(uint64_t old_sig, int delta) {                           
    
    return ((old_sig << 1) ^ delta);// & 0x001F;
}

// ------------------- Updating confidence for the CPLX class ------------------ // 
int update_conf(int stride, int pred_stride, int conf) {

    return conf;
}

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " L1D Complex-Stride prefetcher" << endl;
    
}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

	// --------------------- Add Complex-Stride pf_address logic here --------------------- //

    // Check if entry corresponding to IP is available
    int IP_table_entry = NUM_IP_TABLE_ENTRIES;
    for(int i = 0; i < NUM_IP_TABLE_ENTRIES; i++)
    {
        if(trackers_ip[i].ip == ip)
        {
            IP_table_entry = i;
            break;
        }
    }

    // Get empty entry if entry corresponding to IP is not available
    if(IP_table_entry == NUM_IP_TABLE_ENTRIES)
    {
        for(int i = 0; i < NUM_IP_TABLE_ENTRIES; i++)
        {
            if(trackers_ip[i].valid == 0)
            {
                IP_table_entry = i;
                break;
            }
        }
    }

    // Evict an entry if no entry available
    // For now, the unlucky entry is chosen by performing a mod NUM_IP_TABLE_ENTRIES operation on the ip
    // LRU could be implemented later off if performance goes to the gutters with this approach
    if(IP_table_entry == NUM_IP_TABLE_ENTRIES)
    {
        IP_table_entry = ip % NUM_IP_TABLE_ENTRIES;
        trackers_ip[IP_table_entry].valid = 0;
    }

    // Check if entry is valid (if not -> indicates first access)
    if(trackers_ip[IP_table_entry].valid == 0)
    {
        trackers_ip[IP_table_entry].valid = 1;
        trackers_ip[IP_table_entry].ip = ip;
        trackers_ip[IP_table_entry].signature = 0;
        trackers_ip[IP_table_entry].target_addr = addr >> LOG2_BLOCK_SIZE;
    }
    else
    {
        // Begin training CSPT
        int stride_observed = (addr >> LOG2_BLOCK_SIZE) - trackers_ip[IP_table_entry].target_addr;
        uint64_t signature_observed = trackers_ip[IP_table_entry].signature;

        // Update target address
        trackers_ip[IP_table_entry].target_addr = addr >> LOG2_BLOCK_SIZE;

        // Set CSPT_entry to max possible value
        int CSPT_entry = NUM_IP_TABLE_ENTRIES;
        
        // Try to find entry available corresponding to signature
        for(int i = 0; i < NUM_IP_TABLE_ENTRIES; i++)
        {
            if(trackers_cspt[i].signature == signature_observed)
            {
                CSPT_entry = i;
                break;
            }
        }

        // If no entry found, find an invalid one
        if(CSPT_entry == NUM_IP_TABLE_ENTRIES)
        {
            for(int i = 0; i < NUM_IP_TABLE_ENTRIES; i++)
            {
                if(trackers_cspt[i].valid == 0)
                {
                    CSPT_entry = i;
                    break;
                }
            }
        }

        // If there are no available invalid entries, evict an entry
        // For now, the unlucky entry is chosen by performing a mod NUM_IP_TABLE_ENTRIES operation on the ip
        // LRU could be implemented later off if performance goes to the gutters with this approach
        if(CSPT_entry == NUM_IP_TABLE_ENTRIES)
        {
            CSPT_entry = signature_observed % NUM_IP_TABLE_ENTRIES;
            trackers_cspt[CSPT_entry].valid = 0;
        }

        // Check if the entry is valid
        if(trackers_cspt[CSPT_entry].valid == 0)
        {
            trackers_cspt[CSPT_entry].valid = 1;
            trackers_cspt[CSPT_entry].stride = stride_observed;
            trackers_cspt[CSPT_entry].confidence = 0;
            trackers_cspt[CSPT_entry].signature = signature_observed;
        }
        else
        {
            // Increment confidence bits till they saturate
            if(trackers_cspt[CSPT_entry].stride == stride_observed)
            {
                if(trackers_cspt[CSPT_entry].confidence != 3)
                {
                    trackers_cspt[CSPT_entry].confidence++;
                }
            }
            else
            {
                if(trackers_cspt[CSPT_entry].confidence != 0)
                {
                    trackers_cspt[CSPT_entry].confidence--;
                }
                // Update prediction if confidence is 0
                else
                {
                    trackers_cspt[CSPT_entry].stride = stride_observed;
                }
            }
        }

        trackers_ip[IP_table_entry].signature = update_sig_l1(signature_observed, trackers_cspt[CSPT_entry].stride);

        // Begin prefetching
        uint64_t prefetch_signature = trackers_ip[IP_table_entry].signature;
        uint64_t prefetch_address = addr;

        // Repeat process PREFETCH_DEGREE number of times
        for(int i = 0; i < PREFETCH_DEGREE; i++)
        {
            int CSPT_entry = NUM_IP_TABLE_ENTRIES;

            // Find CSPT entry corresponding to prefetch signature
            for(int j = 0; j < NUM_IP_TABLE_ENTRIES; j++)
            {
                if(trackers_cspt[j].signature == prefetch_signature)
                {
                    CSPT_entry = j;
                    break;
                }
            }

            // If no entry is found, stop prefetching (since there is no prediction available)
            if(CSPT_entry == NUM_IP_TABLE_ENTRIES)
            {
                break;
            } 
            else
            {
                prefetch_address = ((prefetch_address >> LOG2_BLOCK_SIZE) + trackers_cspt[CSPT_entry].stride) << LOG2_BLOCK_SIZE;

                // Check if prefetch address is in the same page
                if(prefetch_address >> LOG2_PAGE_SIZE != addr >> LOG2_PAGE_SIZE)
                {
                    break;
                }
                else
                {
                    // Prefetch only if confidence is saturated and the stride is non-zero
                    if(trackers_cspt[CSPT_entry].confidence == 3 && trackers_cspt[CSPT_entry].stride != 0)
                    {
                        prefetch_line(ip, addr, prefetch_address, FILL_L1, 0);
                        //cout << "Prefetch for " << addr << " with stride " << trackers_cspt[CSPT_entry].stride << " and confidence " << (int)trackers_cspt[CSPT_entry].confidence << endl;
                    }
                    prefetch_signature = update_sig_l1(prefetch_signature, trackers_cspt[CSPT_entry].stride);
                }
            }
        }
    }

	// prefetch_line(ip, addr, pf_address, FILL_L1, 0);

	return;

}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D complex stride prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //