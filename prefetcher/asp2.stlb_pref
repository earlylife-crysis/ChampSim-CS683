#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define IP_TRACKER_COUNT 64           // Number of IP trackers
// ------------------------- DO NOT CHANGE -------------------------------- //

#define PREFETCH_DEGREE 2             // Prefetch degree - you need to vary this!

class IP_TRACKER {
  public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;
    uint64_t target_addr;
    int stride;
    uint8_t state;
    uint8_t valid;

    // Defining the constructor
    IP_TRACKER()
    {
        valid = 0;
        ip = 0;
        stride = 0;
        state = 0;
        target_addr = 0;
    }
};

IP_TRACKER trackers[IP_TRACKER_COUNT];

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::stlb_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " STLB arbitrary stride prefetcher" << endl;

}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::stlb_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint64_t prefetch_id, uint8_t instruction)
{
    // ------------------------ Add Arbitrary Stride pf_address logic here ----------------------- // 
    
    // Check if IP is already being tracked
    int RPT_entry = IP_TRACKER_COUNT;
    for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
    {
        if(trackers[entry_count].ip == ip)
        {
            RPT_entry = entry_count;
            break;
        }
    }

    // Finding an empty IP Tracker entry (if IP is not being tracked already)
    if(RPT_entry == IP_TRACKER_COUNT)
    {
        for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
        {
            if(trackers[entry_count].valid == 0)
            {
                RPT_entry = entry_count;
                break;
            }
        }
    }

    // Clearing one of the entries if no empty entry found
    // For now, the unlucky entry is chosen by performing a mod 64 operation on the ip
    // LRU could be implemented later off if performance goes to the gutters with this approach
    if(RPT_entry == IP_TRACKER_COUNT)
    {   
        RPT_entry = ip % IP_TRACKER_COUNT;
        trackers[RPT_entry].valid = 0;
    }

    // Updating the trackers
    // First check if the entry is valid (indicates first update if it isn't)
    if(trackers[RPT_entry].valid == 0)
    {
        trackers[RPT_entry].valid = 1;
        trackers[RPT_entry].ip = ip;
        trackers[RPT_entry].target_addr = addr >> LOG2_PAGE_SIZE;
        trackers[RPT_entry].stride = 0;
        trackers[RPT_entry].state = 0;  // Corresponds to the base state
    }
    else
    {
        int new_stride = (addr >> LOG2_PAGE_SIZE) - trackers[RPT_entry].target_addr;
        trackers[RPT_entry].target_addr = addr >> LOG2_PAGE_SIZE;
        
        // Check if new stride is the same as old stride
        if(trackers[RPT_entry].stride == new_stride)
        {
            // Update state only if the state is transient(0 or 1)
            if (trackers[RPT_entry].state != 2)
            {
                trackers[RPT_entry].state++;
            }
        }
        // If stride not the same, revert to state 0
        else
        {
            trackers[RPT_entry].stride = new_stride;
            trackers[RPT_entry].state = 0;
        }

        // Call for prefetch if state is steady (2)
        if(trackers[RPT_entry].state == 2)
        {
            for(int degree_count = 0; degree_count < PREFETCH_DEGREE; degree_count++)
            {
                // Compute prefetch address by adding multiples of stride
                uint64_t pf_address = ((addr >> LOG2_PAGE_SIZE) + (trackers[RPT_entry].stride * (degree_count + 1))) << LOG2_PAGE_SIZE;

                // Check if stride is zero (and break if zero)
                if(trackers[RPT_entry].stride == 0)
                {
                    break;
                }
                
                prefetch_translation(ip, pf_address, (int)2, 0, prefetch_id, instruction);
            }
        }
    }

    // prefetch_translation(ip, pf_address, (int)2, 0, prefetch_id, instruction);
    
    return;
}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::stlb_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    return;
}

void CACHE::stlb_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " STLB arbitrary stride prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //