#include "cache.h"

// Additional header file to check STLB hit count
#include "ooo_cpu.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define IP_TRACKER_COUNT 64           // Number of IP trackers_asp
// ------------------------- DO NOT CHANGE -------------------------------- //

#define PREFETCH_DEGREE 8             // Prefetch degree - you need to vary this!

// Defining phase size to determine how many prefetches to allow
#define PHASE_SIZE 64

// Variable to hold how many prefetches are permissible and how many have been done
int allowed_prefetches = PHASE_SIZE / 2;
int prefetches_done = 0;

// Variable to hold previous hit count
int prev_hit_count = 0;

// Define how much allowed_prefetches can be changed by
#define PHASE_SIZE_DELTA 16

// Variable for threshold of hits for which allowed prefetches are increased/decreased
int PHASE_THRESHOLD_UPPER = allowed_prefetches / 2;
int PHASE_THRESHOLD_LOWER = allowed_prefetches / 2;

class IP_TRACKER {
  public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;
    uint64_t target_addr;
    int stride;
    uint8_t state;
    uint8_t valid;

    // Defining the constructor
    IP_TRACKER()
    {
        valid = 0;
        ip = 0;
        stride = 0;
        state = 0;
        target_addr = 0;
    }
};

IP_TRACKER trackers_asp[IP_TRACKER_COUNT];

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::stlb_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " STLB arbitrary stride prefetcher" << endl;

}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::stlb_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint64_t prefetch_id, uint8_t instruction)
{
    // ------------------------ Add Arbitrary Stride pf_address logic here ----------------------- // 
    
    // Check if phase threshold is exceeded
    if(warmup_complete[cpu] == 1)
    {
        if(prefetches_done > PHASE_SIZE)
        {
            prefetches_done = 0;
            
            // Check number of STLB hits and make decision
            if((ooo_cpu[cpu].STLB.sim_hit[cpu][5] - prev_hit_count) > PHASE_THRESHOLD_UPPER)
            {
                allowed_prefetches += PHASE_SIZE_DELTA;
                if(allowed_prefetches >= PHASE_SIZE)
                {
                    allowed_prefetches = PHASE_SIZE;
                }
            }
            else if((ooo_cpu[cpu].STLB.sim_hit[cpu][5] - prev_hit_count) < PHASE_THRESHOLD_LOWER)
            {
                allowed_prefetches -= PHASE_SIZE_DELTA;
                if(allowed_prefetches <= 0)
                {
                    allowed_prefetches = PHASE_SIZE_DELTA;
                }
            }
            PHASE_THRESHOLD_UPPER = allowed_prefetches / 2;
            PHASE_THRESHOLD_LOWER = allowed_prefetches / 2;

            //cout << "Allowed prefetches " << allowed_prefetches << " with parameter " << ooo_cpu[cpu].STLB.sim_hit[cpu][5] - prev_hit_count << "\n";
            prev_hit_count = ooo_cpu[cpu].STLB.sim_hit[cpu][5];
        }
    }

    // Check if IP is already being tracked
    int RPT_entry = IP_TRACKER_COUNT;
    for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
    {
        if(trackers_asp[entry_count].ip == ip)
        {
            RPT_entry = entry_count;
            break;
        }
    }

    // Finding an empty IP Tracker entry (if IP is not being tracked already)
    if(RPT_entry == IP_TRACKER_COUNT)
    {
        for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
        {
            if(trackers_asp[entry_count].valid == 0)
            {
                RPT_entry = entry_count;
                break;
            }
        }
    }

    // Clearing one of the entries if no empty entry found
    // For now, the unlucky entry is chosen by performing a mod 64 operation on the ip
    // LRU could be implemented later off if performance goes to the gutters with this approach
    if(RPT_entry == IP_TRACKER_COUNT)
    {   
        RPT_entry = ip % IP_TRACKER_COUNT;
        trackers_asp[RPT_entry].valid = 0;
    }

    // Updating the trackers_asp
    // First check if the entry is valid (indicates first update if it isn't)
    if(trackers_asp[RPT_entry].valid == 0)
    {
        trackers_asp[RPT_entry].valid = 1;
        trackers_asp[RPT_entry].ip = ip;
        trackers_asp[RPT_entry].target_addr = addr >> LOG2_PAGE_SIZE;
        trackers_asp[RPT_entry].stride = 0;
        trackers_asp[RPT_entry].state = 0;  // Corresponds to the base state
    }
    else
    {
        int new_stride = (addr >> LOG2_PAGE_SIZE) - trackers_asp[RPT_entry].target_addr;
        trackers_asp[RPT_entry].target_addr = addr >> LOG2_PAGE_SIZE;
        
        // Check if new stride is the same as old stride
        if(trackers_asp[RPT_entry].stride == new_stride)
        {
            // Update state only if the state is transient(0 or 1)
            if (trackers_asp[RPT_entry].state != 2)
            {
                trackers_asp[RPT_entry].state++;
            }
        }
        // If stride not the same, revert to state 0
        else
        {
            trackers_asp[RPT_entry].stride = new_stride;
            trackers_asp[RPT_entry].state = 0;
        }

        // Call for prefetch if state is steady (2)
        if(trackers_asp[RPT_entry].state == 2)
        {
            for(int degree_count = 0; degree_count < PREFETCH_DEGREE; degree_count++)
            {
                // Compute prefetch address by adding multiples of stride
                uint64_t pf_address = ((addr >> LOG2_PAGE_SIZE) + (trackers_asp[RPT_entry].stride * (degree_count + 1))) << LOG2_PAGE_SIZE;

                // Check if stride is zero (and break if zero)
                if(trackers_asp[RPT_entry].stride == 0)
                {
                    break;
                }
                
                // Allow prefetch only if below threshold
                if(prefetches_done < allowed_prefetches)
                {
                    prefetch_translation(ip, pf_address, (int)2, 0, prefetch_id, instruction);
                }

                // Increment prefetch count
                prefetches_done++;
            }
        }
    }

    // prefetch_translation(ip, pf_address, (int)2, 0, prefetch_id, instruction);
        
    return;
}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::stlb_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    return;
}

void CACHE::stlb_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " STLB arbitrary stride prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //