#include "cache.h"

// Include to obtain prefetcher stats
#include "ooo_cpu.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define NUM_IP_TABLE_L1_ENTRIES 1024  // IP table entries
#define IP_TRACKER_COUNT 64           // Number of IP trackers
#define PREFETCH_DEGREE 5             // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

#define PHASE_LENGTH 4             // Choose an appropriate phase length

uint64_t num_prefs = 0;               // To keep a track of the number of prefetched lines
uint8_t training_complete = 0;        // To keep track of whether training is completed

// Track the accuracy of the different prefetchers
double accuracy_ip;
double accuracy_cplx;
double accuracy_nl;

// Additional variables to hold previous states during training
uint64_t prev_pf_useful, prev_pf_lower_level;

#define IP_STRIDE 1                   // IP-Stride Prefetcher
#define CPLX 2                        // Complex-Stride Prefetcher
#define NL 3                          // Next-line Prefetcher

uint16_t prefetcher = IP_STRIDE;      // Start with the IP-Stride Prefetcher

class IP_TRACKER {
  public:
    // ------------------------- Define the IP_TRACKER class here ------------------------- //
    uint64_t ip;
    uint64_t target_addr;
    int stride;
    uint8_t state;
    uint8_t valid;

    // Defining the constructor
    IP_TRACKER()
    {
        valid = 0;
        ip = 0;
        stride = 0;
        state = 0;
        target_addr = 0;
    } 
};

IP_TRACKER trackers[IP_TRACKER_COUNT];

class IP_TABLE_CPLX {
    public:
    uint8_t valid;        // Validity bit
    uint64_t ip;          // IP
    uint64_t signature;   // Signature corresponding to IP
    uint64_t target_addr; // Address targetted by IP (used to compute stride)

    // Defining the constructor
    IP_TABLE_CPLX()
    {
        valid = 0;
        ip = 0;
        signature = 0;
        target_addr = 0;
    }
};

// Add CSPT class
class CSPT {
    public:
    uint8_t valid;
    uint64_t signature;
    int stride;
    uint8_t confidence;

    // Defining the constructor
    CSPT()
    {
        valid = 0;
        signature = 0;
        stride = 0;
        confidence = 0;
    }
};

// Changed name of table (for convenience)
IP_TABLE_CPLX trackers_ip[NUM_IP_TABLE_L1_ENTRIES];

// Create CSPT table
CSPT trackers_cspt[NUM_IP_TABLE_L1_ENTRIES];

// ------------------------- Updating the signature ---------------------------- // 
uint64_t update_sig_l1(uint64_t old_sig, int delta) {                           
    
    return ((old_sig << 1) ^ delta) & 0x001F;
}

// ------------------- Updating confidence for the CPLX class ------------------ // 
int update_conf(int stride, int pred_stride, int conf) {

    return conf;
}

// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{
	cout << "CPU " << cpu << " L1D Optimized prefetcher" << endl;
    
}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

    // Obtain prefetch accuracy and change prefetcher (if in training mode)
    if(ooo_cpu[cpu].L1D.pf_lower_level > PHASE_LENGTH && prefetcher == IP_STRIDE && training_complete == 0)
    {
        accuracy_ip = (double)(ooo_cpu[cpu].L1D.sim_hit[cpu][2] * 100) / ooo_cpu[cpu].L1D.pf_lower_level;
        cout << "IP_STRIDE Accuracy is " << accuracy_ip << " \n";

        prev_pf_useful = ooo_cpu[cpu].L1D.sim_hit[cpu][2];
        prev_pf_lower_level = ooo_cpu[cpu].L1D.pf_lower_level;

        //cout << ooo_cpu[cpu].L1D.sim_hit[cpu][2] << " " << ooo_cpu[cpu].L1D.pf_lower_level << "\n";
        prefetcher = CPLX;
        cout << "Switching to CPLX L1D prefetcher\n";
    }
    else if(ooo_cpu[cpu].L1D.pf_lower_level > 2 * PHASE_LENGTH && prefetcher == CPLX && training_complete == 0)
    {
        accuracy_cplx = (double)((ooo_cpu[cpu].L1D.sim_hit[cpu][2] - prev_pf_useful) * 100) / (ooo_cpu[cpu].L1D.pf_lower_level - prev_pf_lower_level);
        cout << "CPLX Accuracy is " << accuracy_cplx << " \n";

        prev_pf_useful = ooo_cpu[cpu].L1D.sim_hit[cpu][2];
        prev_pf_lower_level = ooo_cpu[cpu].L1D.pf_lower_level;

        //cout << ooo_cpu[cpu].L1D.sim_hit[cpu][2] << " " << ooo_cpu[cpu].L1D.pf_lower_level << "\n";
        prefetcher = NL;
        cout << "Switching to NL L1D prefetcher\n";

        // Removing all PQ entries
        //ooo_cpu[cpu].L1D.PQ.head = ooo_cpu[cpu].L1D.PQ.tail;
    }
    // Complete training and choose the best prefetcher
    else if(ooo_cpu[cpu].L1D.pf_lower_level > 3 * PHASE_LENGTH && prefetcher == NL && training_complete == 0)
    {
        accuracy_nl = (double)((ooo_cpu[cpu].L1D.sim_hit[cpu][2] - prev_pf_useful) * 100) / (ooo_cpu[cpu].L1D.pf_lower_level - prev_pf_lower_level);
        cout << "NL Accuracy is " << accuracy_nl << " \n";
        //cout << ooo_cpu[cpu].L1D.sim_hit[cpu][2] << " " << ooo_cpu[cpu].L1D.pf_lower_level << "\n";

        // Mark training as completed
        training_complete = 1;

        // Choose prefetcher with highest accuracy
        if(accuracy_ip > accuracy_cplx && accuracy_ip > accuracy_nl)
        {
            prefetcher = IP_STRIDE;
            cout << "Prefetcher set to IP_STRIDE\n";
        }
        else if(accuracy_cplx > accuracy_ip && accuracy_cplx > accuracy_nl)
        {
            prefetcher = CPLX;
            cout << "Prefetcher set to CPLX\n";
        }
        else if(accuracy_nl > accuracy_ip && accuracy_nl > accuracy_cplx)
        {
            prefetcher = NL;
            cout << "Prefetcher set to NL\n";
        }
        else
        {
            assert(0);
        }

    }

    if (warmup_complete[0] == 1) {
        if (prefetcher == IP_STRIDE) {
            // IP-Stride Prefetcher
            // ------------------------ Add IP-Stride pf_address logic here ----------------------- //
            // Check if IP is already being tracked
            int RPT_entry = IP_TRACKER_COUNT;
            for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
            {
                if(trackers[entry_count].ip == ip)
                {
                    RPT_entry = entry_count;
                    break;
                }
            }

            // Finding an empty IP Tracker entry (if IP is not being tracked already)
            if(RPT_entry == IP_TRACKER_COUNT)
            {
                for(int entry_count = 0; entry_count < IP_TRACKER_COUNT; entry_count++)
                {
                    if(trackers[entry_count].valid == 0)
                    {
                        RPT_entry = entry_count;
                        break;
                    }
                }
            }

            // Clearing one of the entries if no empty entry found
            // For now, the unlucky entry is chosen by performing a mod 64 operation on the ip
            // LRU could be implemented later off if performance goes to the gutters with this approach
            if(RPT_entry == IP_TRACKER_COUNT)
            {   
                RPT_entry = ip % IP_TRACKER_COUNT;
                trackers[RPT_entry].valid = 0;
            }

            // Updating the trackers
            // First check if the entry is valid (indicates first update if it isn't)
            if(trackers[RPT_entry].valid == 0)
            {
                trackers[RPT_entry].valid = 1;
                trackers[RPT_entry].ip = ip;
                trackers[RPT_entry].target_addr = addr >> LOG2_BLOCK_SIZE;
                trackers[RPT_entry].stride = 0;
                trackers[RPT_entry].state = 0;  // Corresponds to the base state
            }
            else
            {
                int new_stride = (addr >> LOG2_BLOCK_SIZE) - trackers[RPT_entry].target_addr;
                trackers[RPT_entry].target_addr = addr >> LOG2_BLOCK_SIZE;
                
                // Check if new stride is the same as old stride
                if(trackers[RPT_entry].stride == new_stride)
                {
                    // Update state only if the state is transient(0 or 1)
                    if (trackers[RPT_entry].state != 2)
                    {
                        trackers[RPT_entry].state++;
                    }
                }
                // If stride not the same, revert to state 0
                else
                {
                    trackers[RPT_entry].stride = new_stride;
                    trackers[RPT_entry].state = 0;
                }

                // Call for prefetch if state is steady (2)
                if(trackers[RPT_entry].state == 2)
                {
                    for(int degree_count = 0; degree_count < PREFETCH_DEGREE; degree_count++)
                    {
                        // Compute prefetch address by adding multiples of stride
                        uint64_t pf_address = ((addr >> LOG2_BLOCK_SIZE) + (trackers[RPT_entry].stride * (degree_count + 1))) << LOG2_BLOCK_SIZE;

                        // Check if prefetch address is in the same page as base address (break if not)
                        if(pf_address >> LOG2_PAGE_SIZE != addr >> LOG2_PAGE_SIZE)
                        {
                            break;
                        }

                        // Check if stride is zero (and break if zero)
                        if(trackers[RPT_entry].stride == 0)
                        {
                            break;
                        }

                        prefetch_line(ip, addr, pf_address, FILL_L1, 0);

                        // Increment number of prefetchers
                        num_prefs++;
                        //cout << num_prefs << " \n";
                    }
                }
            }

            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);

            return;
                
            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else if (prefetcher == CPLX) {
            // Complex-Stride Prefetcher
            // --------------------- Add Complex-Stride pf_address logic here --------------------- // 
            // Check if entry corresponding to IP is available
            int IP_table_entry = NUM_IP_TABLE_L1_ENTRIES;
            for(int i = 0; i < NUM_IP_TABLE_L1_ENTRIES; i++)
            {
                if(trackers_ip[i].ip == ip)
                {
                    IP_table_entry = i;
                    break;
                }
            }

            // Get empty entry if entry corresponding to IP is not available
            if(IP_table_entry == NUM_IP_TABLE_L1_ENTRIES)
            {
                for(int i = 0; i < NUM_IP_TABLE_L1_ENTRIES; i++)
                {
                    if(trackers_ip[i].valid == 0)
                    {
                        IP_table_entry = i;
                        break;
                    }
                }
            }

            // Evict an entry if no entry available
            // For now, the unlucky entry is chosen by performing a mod NUM_IP_TABLE_L1_ENTRIES operation on the ip
            // LRU could be implemented later off if performance goes to the gutters with this approach
            if(IP_table_entry == NUM_IP_TABLE_L1_ENTRIES)
            {
                IP_table_entry = ip % NUM_IP_TABLE_L1_ENTRIES;
                trackers_ip[IP_table_entry].valid = 0;
            }

            // Check if entry is valid (if not -> indicates first access)
            if(trackers_ip[IP_table_entry].valid == 0)
            {
                trackers_ip[IP_table_entry].valid = 1;
                trackers_ip[IP_table_entry].ip = ip;
                trackers_ip[IP_table_entry].signature = 0;
                trackers_ip[IP_table_entry].target_addr = addr >> LOG2_BLOCK_SIZE;
            }
            else
            {
                // Begin training CSPT
                int stride_observed = (addr >> LOG2_BLOCK_SIZE) - trackers_ip[IP_table_entry].target_addr;
                uint64_t signature_observed = trackers_ip[IP_table_entry].signature;

                // Update target address
                trackers_ip[IP_table_entry].target_addr = addr >> LOG2_BLOCK_SIZE;

                // Set CSPT_entry to max possible value
                int CSPT_entry = NUM_IP_TABLE_L1_ENTRIES;
                
                // Try to find entry available corresponding to signature
                for(int i = 0; i < NUM_IP_TABLE_L1_ENTRIES; i++)
                {
                    if(trackers_cspt[i].signature == signature_observed)
                    {
                        CSPT_entry = i;
                        break;
                    }
                }

                // If no entry found, find an invalid one
                if(CSPT_entry == NUM_IP_TABLE_L1_ENTRIES)
                {
                    for(int i = 0; i < NUM_IP_TABLE_L1_ENTRIES; i++)
                    {
                        if(trackers_cspt[i].valid == 0)
                        {
                            CSPT_entry = i;
                            break;
                        }
                    }
                }

                // If there are no available invalid entries, evict an entry
                // For now, the unlucky entry is chosen by performing a mod NUM_IP_TABLE_L1_ENTRIES operation on the ip
                // LRU could be implemented later off if performance goes to the gutters with this approach
                if(CSPT_entry == NUM_IP_TABLE_L1_ENTRIES)
                {
                    CSPT_entry = signature_observed % NUM_IP_TABLE_L1_ENTRIES;
                    trackers_cspt[CSPT_entry].valid = 0;
                }

                // Check if the entry is valid
                if(trackers_cspt[CSPT_entry].valid == 0)
                {
                    trackers_cspt[CSPT_entry].valid = 1;
                    trackers_cspt[CSPT_entry].stride = stride_observed;
                    trackers_cspt[CSPT_entry].confidence = 0;
                    trackers_cspt[CSPT_entry].signature = signature_observed;
                }
                else
                {
                    // Increment confidence bits till they saturate
                    if(trackers_cspt[CSPT_entry].stride == stride_observed)
                    {
                        if(trackers_cspt[CSPT_entry].confidence != 3)
                        {
                            trackers_cspt[CSPT_entry].confidence++;
                        }
                    }
                    else
                    {
                        if(trackers_cspt[CSPT_entry].confidence != 0)
                        {
                            trackers_cspt[CSPT_entry].confidence--;
                        }
                        // Update prediction if confidence is 0
                        else
                        {
                            trackers_cspt[CSPT_entry].stride = stride_observed;
                        }
                    }
                }

                trackers_ip[IP_table_entry].signature = update_sig_l1(signature_observed, trackers_cspt[CSPT_entry].stride);

                // Begin prefetching
                uint64_t prefetch_signature = trackers_ip[IP_table_entry].signature;
                uint64_t prefetch_address = addr;

                // Repeat process PREFETCH_DEGREE number of times
                for(int i = 0; i < PREFETCH_DEGREE; i++)
                {
                    int CSPT_entry = NUM_IP_TABLE_L1_ENTRIES;

                    // Find CSPT entry corresponding to prefetch signature
                    for(int j = 0; j < NUM_IP_TABLE_L1_ENTRIES; j++)
                    {
                        if(trackers_cspt[j].signature == prefetch_signature)
                        {
                            CSPT_entry = j;
                            break;
                        }
                    }

                    // If no entry is found, stop prefetching (since there is no prediction available)
                    if(CSPT_entry == NUM_IP_TABLE_L1_ENTRIES)
                    {
                        break;
                    } 
                    else
                    {
                        prefetch_address = ((prefetch_address >> LOG2_BLOCK_SIZE) + trackers_cspt[CSPT_entry].stride) << LOG2_BLOCK_SIZE;

                        // Check if prefetch address is in the same page
                        if(prefetch_address >> LOG2_PAGE_SIZE != addr >> LOG2_PAGE_SIZE)
                        {
                            break;
                        }
                        else
                        {
                            // Prefetch only if confidence is saturated and the stride is non-zero
                            if(trackers_cspt[CSPT_entry].confidence == 3 && trackers_cspt[CSPT_entry].stride != 0)
                            {
                                prefetch_line(ip, addr, prefetch_address, FILL_L1, 0);
                                //cout << "Prefetch for " << addr << " with stride " << trackers_cspt[CSPT_entry].stride << " and confidence " << (int)trackers_cspt[CSPT_entry].confidence << endl;
                                
                                // Increment prefetch count
                                num_prefs++;
                                //cout << num_prefs << " \n";
                            }
                            prefetch_signature = update_sig_l1(prefetch_signature, trackers_cspt[CSPT_entry].stride);
                        }
                    }
                }
            }

            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);

            return;

            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else if (prefetcher == NL) {
            // Next-Line Prefetcher
            // ----------------------- Add Next-line pf_address logic here ------------------------ // 
            for (int i=0; i<PREFETCH_DEGREE; i++) {
                uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

                // ----------------------- Next-line logic ------------------------ // 
                uint64_t pf_address = (cl_addr + ((i+1))) << LOG2_BLOCK_SIZE;

                // only issue a prefetch if the prefetch address is in the same 4 KB page
                // as the current demand access address
                if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
                    break;
                    
                prefetch_line(ip, addr, pf_address, FILL_L1, 0);

                // Increment prefetch count
                num_prefs++;
                //cout << num_prefs << " \n";
            }
            return;

            // prefetch_line(ip, addr, pf_address, FILL_L1, 0);
        }
        else {
            assert(0);
        }
    }

	return;

}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
    
}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{
    
}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D optimized prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
}
// ------------------------- DO NOT CHANGE -------------------------------- //